interface View

поубирать модификаторы public. в нем и так все публично
--------------------------------------------------
class Console
заинлайнить переменную result так как она нигде кроме return не используется:
	try {
            Scanner scanner = new Scanner(System.in);
            return scanner.nextLine();
        } catch (NoSuchElementException e) {
            return null;
        }
--------------------------------------------------
class NotExecuteQueryException

выпилить неиспользуемый import java.sql.SQLException;
---------------------------------------------------
class DataSet 

выпилить неиспользуемый import java.lang.reflect.Array;
---------------------------------------------------
interface DatabaseManager

выпилить неиспользуемый import java.sql.SQLException;
---------------------------------------------------
class JdbcDatabaseManager 

1. Объявленные константы DB_NAME, USER, PASSWORD нигде не используются.
Либо их убрать, либо они сделанына будущее

2. Частое использование конкатенации: 

Я бы использовал StringBuilder для более рационального использования памяти.
StringBuilder может динамически расширяться, обычный String более топорен в этом случае.

2.1 Пример :
  String tableColumnsName = "";
  String tableValues = "";
  
  for (Map.Entry entry : inputData.getData().entrySet()) {
      tableColumnsName += entry.getKey() + ",";
      tableValues += "'" + entry.getValue() + "'" + ",";
  }
  
меняем на это:

 StringBuilder tableColumnsName = new StringBuilder (  );
 StringBuilder tableValues = new StringBuilder (  );
 
 for (Map.Entry entry : inputData.getData().entrySet()) {
         tableColumnsName.append ( entry.getKey () ).append ( "," ) ;
         tableValues.append ( entry.getValue() ).append ( "'" ).append ( "," );
 }		
 
2.2 Или вот такой пример :
   ResultSet resultSet = statement.executeQuery("select exists(select 1 from public.\"" + tableName
                    + "\" where " + conditions + "='" + value + "')");					
я бы заменил на :
  ResultSet resultSet = statement.executeQuery ( String.format("select exists(select 1 from public.\" %s \" where" +
                     " %s = '%s')",tableName, conditions, value ) );

3. В блоках try-with-resourses , в круглых скобках не нужны ";"
---------------------------------------------------
class TableGenerator

Переменные в верхнем регистре
	private String NEW_LINE = "\n";
    private String TABLE_JOINT_SYMBOL = "+";
    private String TABLE_V_SPLIT_SYMBOL = "|";
    private String TABLE_H_SPLIT_SYMBOL = "-";
Скорее всего они должны быть final

---------------------------------------------------
class AbstractCommand 

1.выпилить неиспользуемый import java.sql.SQLException;
2. void checkColumnExist  ,  лишнее объявление переменной boolean columnExist = false;  
Это можно сразу в блоке try объявить, как локалную.
3. void checkRowExist - аналогично пункту 2 (boolean rowExist = false;)
---------------------------------------------------
class Clear

выпилить неиспользуемые
import javax.xml.crypto.Data;
import java.sql.SQLException;
---------------------------------------------------
class Connect

public int count()  сделать приватным . используется только этим классом
---------------------------------------------------
class Create 

выпилить неиспользуемые
import java.sql.SQLException;
import static javax.swing.text.html.HTML.Tag.HEAD;
---------------------------------------------------
class Delete

выпилить неиспользуемые
import com.serg.alex.ua.model.DataSet;
import java.sql.SQLException;
import java.util.List;
import java.util.Set;
---------------------------------------------------
class Drop

выпилить неиспользуемый import java.sql.SQLException;
---------------------------------------------------
class Help 

выпилить неиспользуемый import com.serg.alex.ua.model.DatabaseManager;
---------------------------------------------------
class Insert

выпилить неиспользуемый import java.sql.SQLException;

void process
использование конкатенации 
	for (int i = 1; i < (splitComand.length / 2); i++) {
        insertRow += splitComand[i * 2] + "|" + splitComand[i * 2 + 1] + "|";
    }
заменить на StringBuilder

---------------------------------------------------
class IsConnected

выпилить неиспользуемые
import java.sql.SQLException;
import com.serg.alex.ua.controller.command.Command;
---------------------------------------------------
class Tables

выпилить неиспользуемые
import java.sql.SQLException;
import java.util.Arrays;
---------------------------------------------------
class IsConnectedTest 

private DatabaseManager databaseManager; используется один раз. Можно сделать локальной.
---------------------------------------------------
class Update

выпилить неиспользуемые
import java.sql.SQLException;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.Map;
---------------------------------------------------
class FindTest

@Test
    public void testWrongFormatCommand() throws NotExecuteQueryException {
        try {
            when(databaseManager.getTableData("")).thenThrow(new IllegalArgumentException());
            command.process("find|users|qwe");
        } catch (IllegalArgumentException e) {
            verify(view).write(String.format("", e.getMessage()));
        }
    }
добавь %s в String.format("%s", e.getMessage())
---------------------------------------------------
class IntegrationTest

 //Delete special symbol \r
        String expcted = strWith_R.toString().trim().replace("\r", "");
 //Delete special symbol \r
        String outPutStr = getData().toString().trim().replace("\r", "");
        assertEquals(expcted, outPutStr);
		
 У тебя strWith_R и getData() возвращают String , нет смысла для них вызывать .toString()
 Это по всему классу у тебя так.
 ---------------------------------------------------